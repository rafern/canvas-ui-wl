{
  "version": 3,
  "sources": ["../src/core/WLRoot.js", "../src/core/WLVirtualKeyboardRoot.js", "../src/components/canvas-ui-input-guard.js", "../src/components/virtual-keyboard-ui-root.js"],
  "sourcesContent": ["import { Root, PointerDriver, DOMKeyboardDriver } from '@rafern/canvas-ui';\nimport { vec3, quat } from 'gl-matrix';\n/*global WL*/\n\n// Drivers shared by all UI roots. For some reason, setting up the drivers here\n// crashes Wonderland Editor. Instead, use WLRoot.pointerDriver/keyboardDriver\nlet canvasUIPointerDriver = null;\nlet canvasUIKeyboardDriver = null;\n\n// Mapping for 'cursor' components to canvas-ui pointer IDs. Use\n// WLRoot.pointerIDs or WLRoot.getPointerID(cursor)\nlet canvasUIPointerIDs = null;\n\n/**\n * A canvas-ui Root which automatically manages a mesh and input. For an example\n * on how to use this in a component, see example-components/test-ui-root.js\n * @alias module:WLRoot\n */\nexport class WLRoot extends Root {\n    /**\n     * The shared PointerDriver instance. Getter only. The PointerDriver will\n     * only be created when needed. Used for pointer (mouse & XR controller)\n     * input.\n     * @type {PointerDriver}\n     */\n    static get pointerDriver() {\n        if(canvasUIPointerDriver === null)\n            canvasUIPointerDriver = new PointerDriver();\n\n        return canvasUIPointerDriver;\n    }\n\n    /**\n     * The shared DOMKeyboardDriver instance. Getter only. The DOMKeyboardDriver\n     * will only be created when needed. Used for keyboard input.\n     * @type {DOMKeyboardDriver}\n     */\n    static get keyboardDriver() {\n        if(canvasUIKeyboardDriver === null) {\n            canvasUIKeyboardDriver = new DOMKeyboardDriver();\n            canvasUIKeyboardDriver.bindDOMElem(WL.canvas);\n        }\n\n        return canvasUIKeyboardDriver;\n    }\n\n    /**\n     * A Map mapping each cursor component to a PointerDriver's pointer ID.\n     * @type {Map}\n     */\n    static get pointerIDs() {\n        if(canvasUIPointerIDs === null)\n            canvasUIPointerIDs = new Map();\n\n        return canvasUIPointerIDs;\n    }\n\n    /**\n     * Get the pointer ID assigned to a given cursor component. If the cursor\n     * has no pointer ID assigned, a new pointer ID is registered to the\n     * PointerDriver.\n     * @param cursor The cursor component\n     * @type {number}\n     */\n    static getPointerID(cursor) {\n        const map = WLRoot.pointerIDs;\n        let pointer = map.get(cursor);\n        if(typeof pointer === 'undefined') {\n            pointer = WLRoot.pointerDriver.registerPointer();\n            //console.log('New pointer', pointer, 'registered for cursor', cursor);\n            map.set(cursor, pointer);\n        }\n\n        return pointer;\n    }\n\n    /**\n     * Create a new WLRoot. Note that the properties object can also contain\n     * optional parameters for the canvas-ui Root constructor, and will be\n     * passed to it.\n     *\n     * If texture bleeding prevention is not specified, then it will be enabled\n     * by default.\n     *\n     * If a pointer style handler is not specified, then a default pointer\n     * style handler that changes the cursor style of the Wonderland Engine\n     * canvas will be used.\n     *\n     * @param {Object} wlObject The object where the mesh will be added.\n     * @param {Material} material The material to use for this root's mesh. The material will be cloned.\n     * @param {Widget} child The root's child widget.\n     * @param {Object} [properties] An object containing all optional properties for this Root. Can have all properties from canvas-ui's RootProperties interface.\n     * @param {number} [properties.unitsPerPixel=0.01] The amount of world units per canvas pixel. Determines the pixel density of the mesh.\n     * @param {number | null} [properties.collisionGroup=1] The collision group that this root's collider will belong to. If null, collider and cursor-target will not be added.\n     * @param {boolean} [properties.registerPointerDriver=true] Register the default pointer driver to this root? If collisionGroup is null, this is forced to false.\n     * @param {boolean} [properties.registerKeyboardDriver=true] Register the default keyboard driver to this root?\n     * @constructor\n     */\n    constructor(wlObject, material, child, properties) {\n        properties = {\n            pointerStyleHandler: style => { WL.canvas.style.cursor = style },\n            preventBleeding: true,\n            ...properties\n        };\n\n        super(child, properties);\n\n        const collisionGroup = properties.collisionGroup ?? 1;\n        const registerPointerDriver = properties.registerPointerDriver ?? true;\n        const registerKeyboardDriver = properties.registerKeyboardDriver ?? true;\n        this.unitsPerPixel = properties.unitsPerPixel ?? 0.01;\n        this.texture = null;\n\n        // Create the child object where the mesh and collider will be put.\n        // Starts inactive since the mesh won't be ready yet\n        this.meshObject = WL.scene.addObject(wlObject);\n        this.meshObject.active = false;\n\n        // Setup drivers\n        if(collisionGroup !== null && registerPointerDriver)\n            this.registerDriver(WLRoot.pointerDriver);\n        if(registerKeyboardDriver)\n            this.registerDriver(WLRoot.keyboardDriver);\n\n        // Setup mesh for rendering in world\n        this.mesh = null;\n        this.meshComponent = this.meshObject.addComponent('mesh');\n        // keep clone as a variable instead of accessing it later via\n        // this.meshComponent.material because mesh's material setter wraps the material,\n        // so it can't be reused\n        this.materialClone = material.clone();\n        this.meshComponent.material = this.materialClone;\n        this.oldTexSize = [0, 0];\n        this._setupMesh(1, 0);\n\n        // Setup mouse pointer input\n        if(collisionGroup !== null) {\n            this.collision = this.meshObject.addComponent('collision', {\n                collider: WL.Collider.Box,\n                extents: [1, 1, 0.01],\n                group: 1 << collisionGroup,\n            });\n\n            this.cursorTarget = this.meshObject.addComponent('cursor-target');\n\n            const cursorPos = new Float32Array(3);\n            const pos = new Float32Array(3);\n            const rot = new Float32Array(4);\n            const getCursorPos = cursor => {\n                cursorPos.set(cursor.rayHit.locations[0]);\n                this.meshObject.getTranslationWorld(pos);\n                vec3.sub(cursorPos, cursorPos, pos);\n                quat.invert(rot, this.meshObject.rotationWorld);\n                vec3.transformQuat(cursorPos, cursorPos, rot);\n                vec3.div(cursorPos, cursorPos, this.meshObject.scalingWorld);\n\n                return [\n                    Math.min(Math.max((cursorPos[0] + 1) / 2, 0), 1),\n                    Math.min(Math.max(1 - ((cursorPos[1] + 1) / 2), 0), 1),\n                ];\n            }\n\n            if(registerPointerDriver) {\n                this.cursorTarget.addUnHoverFunction((_, cursor) => {\n                    WLRoot.pointerDriver.leavePointer(\n                        this, WLRoot.getPointerID(cursor)\n                    );\n                });\n                this.cursorTarget.addMoveFunction((_, cursor) => {\n                    WLRoot.pointerDriver.movePointer(\n                        this, WLRoot.getPointerID(cursor), ...getCursorPos(cursor), null, false, false, false\n                    );\n                });\n                this.cursorTarget.addDownFunction((_, cursor) => {\n                    WLRoot.pointerDriver.movePointer(\n                        this, WLRoot.getPointerID(cursor), ...getCursorPos(cursor), 1, false, false, false\n                    );\n                });\n                this.cursorTarget.addUpFunction((_, cursor) => {\n                    WLRoot.pointerDriver.movePointer(\n                        this, WLRoot.getPointerID(cursor), ...getCursorPos(cursor), 0, false, false, false\n                    );\n                });\n            }\n        }\n        else {\n            this.collision = null;\n            this.cursorTarget = null;\n        }\n\n        this.valid = true;\n\n        // Wonderland engine has much stricter texture limits because of the\n        // texture atlas system. Limit canvas to 2048x2048 by default\n        this.maxCanvasWidth = 2048;\n        this.maxCanvasHeight = 2048;\n    }\n\n\n    /**\n     * Do a full update of this root. Does a pre-layout update, resolves the\n     * layout, does a post-layout update and paints. Call this instead of the\n     * individual Root update methods.\n     */\n    update() {\n        if(!this.valid)\n            return;\n\n        // Update (pre-layout)\n        this.preLayoutUpdate();\n\n        // Resolve layout\n        const layoutDirty = this.resolveLayout();\n        const [canvasWidth, canvasHeight] = this.canvasDimensions;\n        if(layoutDirty) {\n            //console.log('Root\\'s layout was dirty, resizing');\n            // Resize and update UV if layout was dirty so that UI is not\n            // stretched\n            const [width, height] = this.dimensions;\n            const [scaleX, scaleY] = this.effectiveScale;\n            this.meshObject.resetScaling();\n            this.meshObject.scale([\n                this.unitsPerPixel * width,\n                this.unitsPerPixel * height,\n                0.01,\n            ]);\n\n            if(this.collision !== null) {\n                this.collision.extents = [\n                    this.meshObject.scalingWorld[0],\n                    this.meshObject.scalingWorld[1],\n                    0.01,\n                ];\n            }\n\n            this._setupMesh(scaleX * width / canvasWidth, 1 - (scaleY * height / canvasHeight));\n        }\n\n        // Update (post-layout)\n        this.postLayoutUpdate();\n\n        // Paint\n        const wasDirty = this.paint();\n\n        // Enable child object if the canvas is enabled\n        this.meshObject.active = this.enabled;\n\n        if(!wasDirty)\n            return;\n\n        // Update texture if needed (if root was dirty)\n        if(this.oldTexSize[0] !== canvasWidth || this.oldTexSize[1] !== canvasHeight) {\n            this.oldTexSize[0] = canvasWidth;\n            this.oldTexSize[1] = canvasHeight;\n            const mat = this.materialClone;\n            const oldTexture = this.texture;\n            this.texture = new WL.Texture(this.canvas);\n            if(mat.shader === 'Flat Opaque Textured' || mat.shader === 'Flat Transparent Textured')\n                mat.flatTexture = this.texture;\n            else if(mat.shader == 'Phong Opaque Textured')\n                mat.diffuseTexture = this.texture;\n            else\n                console.error('Shader', mat.shader, 'not supported by WLRoot');\n\n            // Destroy old texture so that there isn't an accumulation of\n            // texture atlas usage over time\n            if(oldTexture)\n                oldTexture.destroy();\n        }\n        else {\n            //console.log('Root was dirty, updating texture');\n            this.texture.update();\n        }\n    }\n\n    _setVertex(vertexData, i, posX, posY, posZ, normX, normY, normZ, u, v) {\n        vertexData.set([posX, posY, posZ, u, v, normX, normY, normZ], i * WL.Mesh.VERTEX_FLOAT_SIZE);\n    }\n\n    _setUV(vertexData, i, u, v) {\n        vertexData.set([u, v], i * WL.Mesh.VERTEX_FLOAT_SIZE + WL.Mesh.TEXCOORD.U);\n    }\n\n    _setupMesh(u, v) {\n        const indexData = new Uint8Array([\n            0, 3, 1, // top-right triangle\n            0, 2, 3, // bottom-left triangle\n        ]);\n        const vertexData = new Float32Array(4 * WL.Mesh.VERTEX_FLOAT_SIZE);\n        this._setVertex(vertexData, 0, -1,  1, 0, 0, 0, 1, 0, 1); // top-left\n        this._setVertex(vertexData, 1,  1,  1, 0, 0, 0, 1, u, 1); // top-right\n        this._setVertex(vertexData, 2, -1, -1, 0, 0, 0, 1, 0, v); // bottom-left\n        this._setVertex(vertexData, 3,  1, -1, 0, 0, 0, 1, u, v); // bottom-right\n\n        const newMesh = new WL.Mesh({\n            indexData,\n            indexType: WL.MeshIndexType.UnsignedByte,\n            vertexData,\n        });\n\n        this.meshComponent.mesh = newMesh;\n\n        if(this.mesh)\n            this.mesh.destroy();\n\n        this.mesh = newMesh;\n    }\n\n    destroy() {\n        if(this.texture) {\n            this.texture.destroy();\n            this.texture = null;\n        }\n\n        if(this.collision) {\n            this.collision.destroy();\n            this.collision = null;\n        }\n\n        if(this.cursorTarget) {\n            this.cursorTarget.destroy();\n            this.cursorTarget = null;\n        }\n\n        this.meshComponent.destroy();\n        this.meshComponent = null;\n\n        // FIXME material is not destroyed. find a way to do it\n\n        if(this.mesh)\n            this.mesh.destroy();\n\n        this.meshObject.destroy();\n        this.meshObject = null;\n\n        super.destroy();\n    }\n}\n", "import { VirtualKeyboard, defaultVirtualKeyboardTemplate, Margin } from '@rafern/canvas-ui';\nimport { WLRoot } from './WLRoot';\n\n/**\n * A WLRoot with a virtual keyboard, similar to VirtualKeyboardRoot from\n * canvas-ui. Can also be automatically hidden when there is no keyboard focus\n * by callid updateVisibility before calling update. This doesn't need to be\n * directly used, the virtual-keyboard-ui-root component can be used instead.\n * @alias module:WLVirtualKeyboardRoot\n */\nexport class WLVirtualKeyboardRoot extends WLRoot {\n    /**\n     * Create a new WLVirtualKeyboardRoot.\n     * @param {Object} wlObject The object where the mesh will be added.\n     * @param {Material} material The material to use for this root's mesh. The material will be cloned.\n     * @param {Object} [properties] An object containing all optional properties for this Root. Can have all properties from canvas-ui's VirtualKeyboardRootProperties interface and {@link WLRoot}'s properties constructor argument.\n     * @param {KeyboardDriver | null} [properties.keyboardDriver=null] The KeyboardDriver to dispatch key events to. If null (default), WLRoot.keyboardDriver is used.\n     * @constructor\n     */\n    constructor(wlObject, material, properties) {\n        const keyboardDriver = properties?.keyboardDriver ?? WLRoot.keyboardDriver;\n\n        super(\n            wlObject,\n            material,\n            new Margin(\n                new VirtualKeyboard(\n                    keyboardDriver,\n                    properties?.keyboardTemplate ?? defaultVirtualKeyboardTemplate\n                ),\n            ),\n            properties\n        );\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Automatically enables/disables this root if needed/unneeded. Call this\n     * before calling update.\n     */\n    updateVisibility() {\n        if(!this.valid)\n            return;\n\n        // Update visibility of virtual keyboard\n        this.enabled = this.keyboardDriver.needsInput;\n    }\n}\n", "import { PointerHint } from '@rafern/canvas-ui';\nimport { WLRoot } from '../core/WLRoot';\n/*global WL*/\n\nWL.registerComponent('canvas-ui-input-guard', {\n    /** (optional) Name of component to disable if keyboard is in use */\n    keyboardComponentName: {type: WL.Type.String, default: ''},\n    /** (optional) Object containing component to disable if keyboard is in use. Required if keyboardComponentName is set, else, ignored */\n    keyboardObject: {type: WL.Type.Object, default: null},\n    /** (optional) Name of component to disable if pointer is hovering a UI root is in use */\n    pointerComponentName: {type: WL.Type.String, default: ''},\n    /** (optional) Object containing component to disable if pointer is hovering a UI root. Required if pointerComponentName is set, else, ignored */\n    pointerObject: {type: WL.Type.Object, default: null},\n    /** (optional) Object which has a cursor component. Required if pointerObject is set, else, ignored */\n    cursorObject: {type: WL.Type.Object, default:null},\n}, {\n    init() {\n        this.pointer = null;\n        this.pointerComponent = null;\n        this.keyboardComponent = null;\n    },\n    start() {\n        if(this.keyboardComponentName !== '') {\n            if(this.keyboardObject !== null) {\n                const keyboardComponent = this.keyboardObject.getComponent(this.keyboardComponentName);\n                if(keyboardComponent === null)\n                    console.warn('keyboardObject has no component with name', this.keyboardComponentName);\n                else\n                    this.keyboardComponent = keyboardComponent;\n            }\n            else\n                console.warn('keyboardComponentName set in canvas-ui-keyboard-guard, but keyboardObject was not');\n        }\n\n        if(this.pointerComponentName !== '') {\n            if(this.pointerObject !== null) {\n                const pointerComponent = this.pointerObject.getComponent(this.pointerComponentName);\n                if(pointerComponent === null) {\n                    console.warn('pointerObject has no component with name', this.pointerComponentName);\n                    return;\n                }\n\n                if(this.cursorObject !== null) {\n                    const cursor = this.cursorObject.getComponent('cursor');\n                    if(cursor === null)\n                        console.warn('cursorObject set in canvas-ui-keyboard-guard, but cursorObject has no cursor component');\n                    else {\n                        this.pointer = WLRoot.getPointerID(cursor);\n                        this.pointerComponent = pointerComponent;\n                    }\n                }\n                else\n                    console.warn('pointerObject set in canvas-ui-keyboard-guard, but cursorObject was not');\n            }\n            else\n                console.warn('pointerComponentName set in canvas-ui-keyboard-guard, but pointerObject was not');\n        }\n\n    },\n    update(_dt) {\n        if(this.keyboardComponent !== null) {\n            const enable = !WLRoot.keyboardDriver.needsInput;\n            this.keyboardComponent.active = enable;\n        }\n\n        if(this.pointer !== null) {\n            const enable = (WLRoot.pointerDriver.getPointerHint(this.pointer) === PointerHint.None);\n            this.pointerComponent.active = enable;\n        }\n    },\n    onDeactivate() {\n        if(this.keyboardComponent !== null)\n            this.keyboardComponent.active = true;\n\n        if(this.pointerComponent !== null)\n            this.pointerComponent.active = true;\n    },\n});\n", "import { WLVirtualKeyboardRoot } from '../core/WLVirtualKeyboardRoot';\n/*global WL*/\n\nWL.registerComponent('virtual-keyboard-ui-root', {\n    /** Material to apply the canvas texture to */\n    material: {type: WL.Type.Material},\n}, {\n    init() {\n        this.root = new WLVirtualKeyboardRoot(this.object, this.material);\n        this.forceDisabled = false;\n    },\n    update(_dt) {\n        if(this.root && !this.forceDisabled) {\n            this.root.updateVisibility();\n            this.root.update();\n        }\n    },\n    onActivate() {\n        if(this.root) {\n            this.forceDisabled = false;\n            this.root.enabled = true;\n        }\n    },\n    onDeactivate() {\n        if(this.root) {\n            this.forceDisabled = true;\n            this.root.enabled = false;\n        }\n    },\n});\n"],
  "mappings": "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",
  "names": ["Root", "PointerDriver", "DOMKeyboardDriver", "vec3", "quat", "canvasUIPointerDriver", "canvasUIKeyboardDriver", "canvasUIPointerIDs", "WLRoot", "Root", "PointerDriver", "DOMKeyboardDriver", "cursor", "map", "pointer", "wlObject", "material", "child", "properties", "_a", "_b", "_c", "_d", "__spreadValues", "style", "collisionGroup", "registerPointerDriver", "registerKeyboardDriver", "cursorPos", "pos", "rot", "getCursorPos", "vec3", "quat", "_", "layoutDirty", "canvasWidth", "canvasHeight", "width", "height", "scaleX", "scaleY", "wasDirty", "mat", "oldTexture", "vertexData", "i", "posX", "posY", "posZ", "normX", "normY", "normZ", "u", "v", "indexData", "newMesh", "VirtualKeyboard", "defaultVirtualKeyboardTemplate", "Margin", "WLVirtualKeyboardRoot", "WLRoot", "wlObject", "material", "properties", "_a", "_b", "keyboardDriver", "Margin", "VirtualKeyboard", "defaultVirtualKeyboardTemplate", "PointerHint", "keyboardComponent", "pointerComponent", "cursor", "WLRoot", "_dt", "enable", "PointerHint", "WLVirtualKeyboardRoot", "_dt"]
}
