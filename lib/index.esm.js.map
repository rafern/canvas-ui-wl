{
  "version": 3,
  "sources": ["../src/core/WLRoot.js", "../src/core/WLVirtualKeyboardRoot.js", "../src/components/canvas-ui-input-guard.js", "../src/components/virtual-keyboard-ui-root.js"],
  "sourcesContent": ["import { Root, PointerDriver, DOMKeyboardDriver, Theme } from '@rafern/canvas-ui';\nimport { vec3, quat } from 'gl-matrix';\n/*global WL*/\n\n// Drivers shared by all UI roots. For some reason, setting up the drivers here\n// crashes Wonderland Editor. Instead, use WLRoot.pointerDriver/keyboardDriver\nlet canvasUIPointerDriver = null;\nlet canvasUIKeyboardDriver = null;\n\n// Mapping for 'cursor' components to canvas-ui pointer IDs. Use\n// WLRoot.pointerIDs or WLRoot.getPointerID(cursor)\nlet canvasUIPointerIDs = null;\n\n/**\n * A canvas-ui Root which automatically manages a mesh and input. For an example\n * on how to use this in a component, see example-components/test-ui-root.js\n * @alias module:WLRoot\n */\nexport class WLRoot extends Root {\n    /**\n     * The shared PointerDriver instance. Getter only. The PointerDriver will\n     * only be created when needed. Used for pointer (mouse & XR controller)\n     * input.\n     * @type {PointerDriver}\n     */\n    static get pointerDriver() {\n        if(canvasUIPointerDriver === null)\n            canvasUIPointerDriver = new PointerDriver();\n\n        return canvasUIPointerDriver;\n    }\n\n    /**\n     * The shared DOMKeyboardDriver instance. Getter only. The DOMKeyboardDriver\n     * will only be created when needed. Used for keyboard input.\n     * @type {DOMKeyboardDriver}\n     */\n    static get keyboardDriver() {\n        if(canvasUIKeyboardDriver === null) {\n            canvasUIKeyboardDriver = new DOMKeyboardDriver();\n            canvasUIKeyboardDriver.bindDOMElem(WL.canvas);\n        }\n\n        return canvasUIKeyboardDriver;\n    }\n\n    /**\n     * A Map mapping each cursor component to a PointerDriver's pointer ID.\n     * @type {Map}\n     */\n    static get pointerIDs() {\n        if(canvasUIPointerIDs === null)\n            canvasUIPointerIDs = new Map();\n\n        return canvasUIPointerIDs;\n    }\n\n    /**\n     * Get the pointer ID assigned to a given cursor component. If the cursor\n     * has no pointer ID assigned, a new pointer ID is registered to the\n     * PointerDriver.\n     * @param cursor The cursor component\n     * @type {number}\n     */\n    static getPointerID(cursor) {\n        const map = WLRoot.pointerIDs;\n        let pointer = map.get(cursor);\n        if(typeof pointer === 'undefined') {\n            pointer = WLRoot.pointerDriver.registerPointer();\n            //console.log('New pointer', pointer, 'registered for cursor', cursor);\n            map.set(cursor, pointer);\n        }\n\n        return pointer;\n    }\n\n    /**\n     * Create a new WLRoot.\n     * @param {Object} wlObject The object where the mesh will be added.\n     * @param {Material} material The material to use for this root's mesh. The material will be cloned.\n     * @param {Widget} child The root's child widget.\n     * @param {Theme} [theme=new Theme()] The root's theme. If none is supplied, the default theme is used.\n     * @param {number} [unitsPerPixel=0.01] The amount of world units per canvas pixel. Determines the pixel density of the mesh.\n     * @param {number | null} [collisionGroup=1] The collision group that this root's collider will belong to. If null, collider and cursor-target will not be added.\n     * @param {boolean} [registerPointerDriver=true] Register the default pointer driver to this root? If collisionGroup is null, this is forced to false.\n     * @param {boolean} [registerKeyboardDriver=true] Register the default keyboard driver to this root?\n     * @constructor\n     */\n    constructor(wlObject, material, child, theme = new Theme(), unitsPerPixel = 0.01, collisionGroup = 1, registerPointerDriver = true, registerKeyboardDriver = true) {\n        super(child, style => { WL.canvas.style.cursor = style }, theme);\n        this.unitsPerPixel = unitsPerPixel;\n\n        // Create the child object where the mesh and collider will be put.\n        // Starts inactive since the mesh won't be ready yet\n        this.meshObject = WL.scene.addObject(wlObject);\n        this.meshObject.active = false;\n\n        // Setup drivers\n        if(collisionGroup !== null && registerPointerDriver)\n            this.registerDriver(WLRoot.pointerDriver);\n        if(registerKeyboardDriver)\n            this.registerDriver(WLRoot.keyboardDriver);\n\n        // Setup mesh for rendering in world\n        this.mesh = this.meshObject.addComponent('mesh');\n        // keep clone as a variable instead of accessing it later via\n        // this.mesh.material because mesh's material setter wraps the material,\n        // so it can't be reused\n        this.materialClone = material.clone();\n        this.mesh.material = this.materialClone;\n        this.oldTexSize = [0, 0];\n        this._setupMesh(1, 0);\n\n        // Setup mouse pointer input\n        if(collisionGroup !== null) {\n            this.collision = this.meshObject.addComponent('collision', {\n                collider: WL.Collider.Box,\n                extents: [1, 1, 0.01],\n                group: 1 << collisionGroup,\n            });\n\n            const target = this.meshObject.addComponent('cursor-target');\n\n            const cursorPos = new Float32Array(3);\n            const pos = new Float32Array(3);\n            const rot = new Float32Array(4);\n            const getCursorPos = cursor => {\n                cursorPos.set(cursor.rayHit.locations[0]);\n                this.meshObject.getTranslationWorld(pos);\n                vec3.sub(cursorPos, cursorPos, pos);\n                quat.invert(rot, this.meshObject.rotationWorld);\n                vec3.transformQuat(cursorPos, cursorPos, rot);\n                vec3.div(cursorPos, cursorPos, this.meshObject.scalingWorld);\n\n                return [\n                    Math.min(Math.max((cursorPos[0] + 1) / 2, 0), 1),\n                    Math.min(Math.max(1 - ((cursorPos[1] + 1) / 2), 0), 1),\n                ];\n            }\n\n            if(registerPointerDriver) {\n                target.addUnHoverFunction((_, cursor) => {\n                    WLRoot.pointerDriver.leavePointer(\n                        this, WLRoot.getPointerID(cursor)\n                    );\n                });\n                target.addMoveFunction((_, cursor) => {\n                    WLRoot.pointerDriver.movePointer(\n                        this, WLRoot.getPointerID(cursor), ...getCursorPos(cursor), null, false, false, false\n                    );\n                });\n                target.addDownFunction((_, cursor) => {\n                    WLRoot.pointerDriver.movePointer(\n                        this, WLRoot.getPointerID(cursor), ...getCursorPos(cursor), 1, false, false, false\n                    );\n                });\n                target.addUpFunction((_, cursor) => {\n                    WLRoot.pointerDriver.movePointer(\n                        this, WLRoot.getPointerID(cursor), ...getCursorPos(cursor), 0, false, false, false\n                    );\n                });\n            }\n        }\n        else\n            this.collision = null;\n\n        this.valid = true;\n\n        // Wonderland engine has much stricter texture limits because of the\n        // texture atlas system. Limit canvas to 2048x2048 by default\n        this.maxCanvasWidth = 2048;\n        this.maxCanvasHeight = 2048;\n    }\n\n\n    /**\n     * Do a full update of this root. Does a pre-layout update, resolves the\n     * layout, does a post-layout update and paints. Call this instead of the\n     * individual Root update methods.\n     */\n    update() {\n        if(!this.valid)\n            return;\n\n        // Update (pre-layout)\n        this.preLayoutUpdate();\n\n        // Resolve layout\n        const layoutDirty = this.resolveLayout();\n        const [canvasWidth, canvasHeight] = this.canvasDimensions;\n        if(layoutDirty) {\n            //console.log('Root\\'s layout was dirty, resizing');\n            // Resize and update UV if layout was dirty so that UI is not\n            // stretched\n            const [width, height] = this.dimensions;\n            const [scaleX, scaleY] = this.effectiveScale;\n            this.meshObject.resetScaling();\n            this.meshObject.scale([\n                this.unitsPerPixel * width / scaleX,\n                this.unitsPerPixel * height / scaleY,\n                0.01,\n            ]);\n\n            if(this.collision !== null) {\n                this.collision.extents = [\n                    this.meshObject.scalingWorld[0],\n                    this.meshObject.scalingWorld[1],\n                    0.01,\n                ];\n            }\n\n            // XXX FIXME for now, use the workaround (setupMesh)\n            /*const vertexData = this.mesh.mesh.vertexData;\n            const u = scaleX * width / canvasWidth;\n            const v = 1 - (scaleY * height / canvasHeight);\n            this._setUV(vertexData, 1, u, 1); // top-right\n            this._setUV(vertexData, 2, 0, v); // bottom-left\n            this._setUV(vertexData, 3, u, v); // bottom-right\n            this.mesh.mesh = this.mesh.mesh;\n            this.mesh.active = false;\n            this.mesh.active = true;*/\n            this._setupMesh(scaleX * width / canvasWidth, 1 - (scaleY * height / canvasHeight));\n        }\n\n        // Update (post-layout)\n        this.postLayoutUpdate();\n\n        // Paint\n        const wasDirty = this.paint();\n\n        // Enable child object if the canvas is enabled\n        this.meshObject.active = this.enabled;\n\n        if(!wasDirty)\n            return;\n\n        // Update texture if needed (if root was dirty)\n        if(this.oldTexSize[0] !== canvasWidth || this.oldTexSize[1] !== canvasHeight) {\n            this.oldTexSize[0] = canvasWidth;\n            this.oldTexSize[1] = canvasHeight;\n            const mat = this.materialClone;\n            this.texture = new WL.Texture(this.canvas);\n            console.log(mat, 'flatTexture' in mat, 'diffuseTexture' in mat);\n            if(mat.shader === 'Flat Opaque Textured' || mat.shader === 'Flat Transparent Textured')\n                mat.flatTexture = this.texture;\n            else if(mat.shader == 'Phong Opaque Textured')\n                mat.diffuseTexture = this.texture;\n            else\n                console.error('Shader', mat.shader, 'not supported by WLRoot');\n        }\n        else {\n            //console.log('Root was dirty, updating texture');\n            this.texture.update();\n        }\n    }\n\n    _setVertex(vertexData, i, posX, posY, posZ, normX, normY, normZ, u, v) {\n        vertexData.set([posX, posY, posZ, u, v, normX, normY, normZ], i * WL.Mesh.VERTEX_FLOAT_SIZE);\n    }\n\n    _setUV(vertexData, i, u, v) {\n        vertexData.set([u, v], i * WL.Mesh.VERTEX_FLOAT_SIZE + WL.Mesh.TEXCOORD.U);\n    }\n\n    _setupMesh(u, v) {\n        const indexData = new Uint8Array([\n            0, 3, 1, // top-right triangle\n            0, 2, 3, // bottom-left triangle\n        ]);\n        const vertexData = new Float32Array(4 * WL.Mesh.VERTEX_FLOAT_SIZE);\n        this._setVertex(vertexData, 0, -1,  1, 0, 0, 0, 1, 0, 1); // top-left\n        this._setVertex(vertexData, 1,  1,  1, 0, 0, 0, 1, u, 1); // top-right\n        this._setVertex(vertexData, 2, -1, -1, 0, 0, 0, 1, 0, v); // bottom-left\n        this._setVertex(vertexData, 3,  1, -1, 0, 0, 0, 1, u, v); // bottom-right\n        this.mesh.mesh = new WL.Mesh({\n            indexData,\n            indexType: WL.MeshIndexType.UnsignedByte,\n            vertexData,\n        });\n    }\n}\n", "import { VirtualKeyboard, defaultVirtualKeyboardTemplate, Theme, Margin } from '@rafern/canvas-ui';\nimport { WLRoot } from './WLRoot';\n\n/**\n * A WLRoot with a virtual keyboard, similar to VirtualKeyboardRoot from\n * canvas-ui. Can also be automatically hidden when there is no keyboard focus\n * by callid updateVisibility before calling update. This doesn't need to be\n * directly used, the virtual-keyboard-ui-root component can be used instead.\n * @alias module:WLVirtualKeyboardRoot\n */\nexport class WLVirtualKeyboardRoot extends WLRoot {\n    /**\n     * Create a new WLVirtualKeyboardRoot.\n     * @param {Object} wlObject The object where the mesh will be added.\n     * @param {Material} material The material to use for this root's mesh. The material will be cloned.\n     * @param {VirtualKeyboardTemplate} [keyboardTemplate=defaultVirtualKeyboardTemplate] The virtual keyboard's layout template. Uses the US QWERTY layout by default.\n     * @param {KeyboardDriver | null} [keyboardDriver=null] The KeyboardDriver to dispatch key events to. If null (default), WLRoot.keyboardDriver is used.\n     * @param {Theme} [theme=new Theme()] The root's theme. If none is supplied, the default theme is used.\n     * @param {number} [unitsPerPixel=0.01] The amount of world units per canvas pixel. Determines the pixel density of the mesh.\n     * @param {number | null} [collisionGroup=1] The collision group that this root's collider will belong to. If null, collider and cursor-target will not be added.\n     * @param {boolean} [registerPointerDriver=true] Register the default pointer driver to this root? If collisionGroup is null, this is forced to false.\n     * @constructor\n     */\n    constructor(wlObject, material, keyboardTemplate = defaultVirtualKeyboardTemplate, keyboardDriver = null, theme = new Theme(), unitsPerPixel = 0.01, collisionGroup = 1, registerPointerDriver = true) {\n        if(keyboardDriver === null)\n            keyboardDriver = WLRoot.keyboardDriver;\n\n        super(\n            wlObject, material,\n            new Margin(new VirtualKeyboard(keyboardDriver, keyboardTemplate)),\n            theme, unitsPerPixel, collisionGroup, registerPointerDriver, false,\n        );\n\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Automatically enables/disables this root if needed/unneeded. Call this\n     * before calling update.\n     */\n    updateVisibility() {\n        if(!this.valid)\n            return;\n\n        // Update visibility of virtual keyboard\n        this.enabled = this.keyboardDriver.getFocusedRoot() !== null;\n    }\n}\n", "import { PointerHint } from '@rafern/canvas-ui';\nimport { WLRoot } from '../core/WLRoot';\n/*global WL*/\n\nWL.registerComponent('canvas-ui-input-guard', {\n    /** (optional) Name of component to disable if keyboard is in use */\n    keyboardComponentName: {type: WL.Type.String, default: ''},\n    /** (optional) Object containing component to disable if keyboard is in use. Required if keyboardComponentName is set, else, ignored */\n    keyboardObject: {type: WL.Type.Object, default: null},\n    /** (optional) Name of component to disable if pointer is hovering a UI root is in use */\n    pointerComponentName: {type: WL.Type.String, default: ''},\n    /** (optional) Object containing component to disable if pointer is hovering a UI root. Required if pointerComponentName is set, else, ignored */\n    pointerObject: {type: WL.Type.Object, default: null},\n    /** (optional) Object which has a cursor component. Required if pointerObject is set, else, ignored */\n    cursorObject: {type: WL.Type.Object, default:null},\n}, {\n    init() {\n        this.pointer = null;\n        this.pointerComponent = null;\n        this.keyboardComponent = null;\n    },\n    start() {\n        if(this.keyboardComponentName !== '') {\n            if(this.keyboardObject !== null) {\n                const keyboardComponent = this.keyboardObject.getComponent(this.keyboardComponentName);\n                if(keyboardComponent === null)\n                    console.warn('keyboardObject has no component with name', this.keyboardComponentName);\n                else\n                    this.keyboardComponent = keyboardComponent;\n            }\n            else\n                console.warn('keyboardComponentName set in canvas-ui-keyboard-guard, but keyboardObject was not');\n        }\n\n        if(this.pointerComponentName !== '') {\n            if(this.pointerObject !== null) {\n                const pointerComponent = this.pointerObject.getComponent(this.pointerComponentName);\n                if(pointerComponent === null) {\n                    console.warn('pointerObject has no component with name', this.pointerComponentName);\n                    return;\n                }\n\n                if(this.cursorObject !== null) {\n                    const cursor = this.cursorObject.getComponent('cursor');\n                    if(cursor === null)\n                        console.warn('cursorObject set in canvas-ui-keyboard-guard, but cursorObject has no cursor component');\n                    else {\n                        this.pointer = WLRoot.getPointerID(cursor);\n                        this.pointerComponent = pointerComponent;\n                    }\n                }\n                else\n                    console.warn('pointerObject set in canvas-ui-keyboard-guard, but cursorObject was not');\n            }\n            else\n                console.warn('pointerComponentName set in canvas-ui-keyboard-guard, but pointerObject was not');\n        }\n\n    },\n    update(_dt) {\n        if(this.keyboardComponent !== null) {\n            const enable = (WLRoot.keyboardDriver.getFocusedRoot() === null);\n            this.keyboardComponent.active = enable;\n        }\n\n        if(this.pointer !== null) {\n            const enable = (WLRoot.pointerDriver.getPointerHint(this.pointer) === PointerHint.None);\n            this.pointerComponent.active = enable;\n        }\n    },\n    onDeactivate() {\n        if(this.keyboardComponent !== null)\n            this.keyboardComponent.active = true;\n\n        if(this.pointerComponent !== null)\n            this.pointerComponent.active = true;\n    },\n});\n", "import { WLVirtualKeyboardRoot } from '../core/WLVirtualKeyboardRoot';\n/*global WL*/\n\nWL.registerComponent('virtual-keyboard-ui-root', {\n    /** Material to apply the canvas texture to */\n    material: {type: WL.Type.Material},\n}, {\n    init() {\n        this.root = new WLVirtualKeyboardRoot(this.object, this.material);\n        this.forceDisabled = false;\n    },\n    update(_dt) {\n        if(this.root && !this.forceDisabled) {\n            this.root.updateVisibility();\n            this.root.update();\n        }\n    },\n    onActivate() {\n        if(this.root) {\n            this.forceDisabled = false;\n            this.root.enabled = true;\n        }\n    },\n    onDeactivate() {\n        if(this.root) {\n            this.forceDisabled = true;\n            this.root.enabled = false;\n        }\n    },\n});\n"],
  "mappings": "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",
  "names": ["Root", "PointerDriver", "DOMKeyboardDriver", "Theme", "vec3", "quat", "canvasUIPointerDriver", "canvasUIKeyboardDriver", "canvasUIPointerIDs", "WLRoot", "cursor", "map", "pointer", "wlObject", "material", "child", "theme", "unitsPerPixel", "collisionGroup", "registerPointerDriver", "registerKeyboardDriver", "style", "target", "cursorPos", "pos", "rot", "getCursorPos", "_", "layoutDirty", "canvasWidth", "canvasHeight", "width", "height", "scaleX", "scaleY", "wasDirty", "mat", "vertexData", "i", "posX", "posY", "posZ", "normX", "normY", "normZ", "u", "v", "indexData", "VirtualKeyboard", "defaultVirtualKeyboardTemplate", "Theme", "Margin", "WLVirtualKeyboardRoot", "WLRoot", "wlObject", "material", "keyboardTemplate", "defaultVirtualKeyboardTemplate", "keyboardDriver", "theme", "Theme", "unitsPerPixel", "collisionGroup", "registerPointerDriver", "Margin", "VirtualKeyboard", "PointerHint", "keyboardComponent", "pointerComponent", "cursor", "WLRoot", "_dt", "enable", "PointerHint", "WLVirtualKeyboardRoot", "_dt"]
}
