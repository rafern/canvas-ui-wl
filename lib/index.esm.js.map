{
  "version": 3,
  "sources": ["../src/core/WLRoot.js", "../src/core/WLVirtualKeyboardRoot.js", "../src/components/virtual-keyboard-ui-root.js"],
  "sourcesContent": ["import { Root, PointerDriver, DOMKeyboardDriver, Theme } from 'canvas-ui';\nimport { vec3 } from 'gl-matrix';\n/*global WL*/\n\n// Drivers shared by all UI roots. For some reason, setting up the drivers here\n// crashes Wonderland Editor. Instead, use WLRoot.pointerDriver/keyboardDriver\nlet canvasUIPointerDriver = null;\nlet canvasUIKeyboardDriver = null;\n\n// Mapping for 'cursor' components to canvas-ui pointer IDs. Use\n// WLRoot.pointerIDs or WLRoot.getPointerID(cursor)\nlet canvasUIPointerIDs = null;\n\n/**\n * @module canvas-ui-wl\n */\n\n/**\n * A canvas-ui Root which automatically manages a mesh and input. For an example\n * on how to use this in a component, see example-components/test-ui-root.js\n */\nexport class WLRoot extends Root {\n    /**\n     * The shared PointerDriver instance. Getter only. The PointerDriver will\n     * only be created when needed. Used for pointer (mouse & XR controller)\n     * input.\n     * @type {PointerDriver}\n     */\n    static get pointerDriver() {\n        if(canvasUIPointerDriver === null)\n            canvasUIPointerDriver = new PointerDriver();\n\n        return canvasUIPointerDriver;\n    }\n\n    /**\n     * The shared DOMKeyboardDriver instance. Getter only. The DOMKeyboardDriver\n     * will only be created when needed. Used for keyboard input.\n     * @type {DOMKeyboardDriver}\n     */\n    static get keyboardDriver() {\n        if(canvasUIKeyboardDriver === null) {\n            canvasUIKeyboardDriver = new DOMKeyboardDriver();\n            canvasUIKeyboardDriver.bindDOMElem(WL.canvas);\n        }\n\n        return canvasUIKeyboardDriver;\n    }\n\n    /**\n     * A Map mapping each cursor component to a PointerDriver's pointer ID.\n     * @type {Map}\n     */\n    static get pointerIDs() {\n        if(canvasUIPointerIDs === null)\n            canvasUIPointerIDs = new Map();\n\n        return canvasUIPointerIDs;\n    }\n\n    /**\n     * Get the pointer ID assigned to a given cursor component. If the cursor\n     * has no pointer ID assigned, a new pointer ID is registered to the\n     * PointerDriver.\n     * @param cursor The cursor component\n     * @type {number}\n     */\n    static getPointerID(cursor) {\n        const map = WLRoot.pointerIDs;\n        let pointer = map.get(cursor);\n        if(typeof pointer === 'undefined') {\n            pointer = WLRoot.pointerDriver.registerPointer();\n            //console.log('New pointer', pointer, 'registered for cursor', cursor);\n            map.set(cursor, pointer);\n        }\n\n        return pointer;\n    }\n\n    /**\n     * Create a new WLRoot.\n     * @param wlObject {Object} The object where the mesh will be added\n     * @param material {Material} The material to use for this root's mesh. The material will be cloned\n     * @param child {Widget} The root's child widget\n     * @param theme {Theme} The root's theme. If none is supplied, the default theme is used\n     * @param unitsPerPixel {number} The amount of world units per canvas pixel. Determines the pixel density of the mesh\n     * @param registerPointerDriver {boolean} Register the default pointer driver to this root?\n     * @param registerKeyboardDriver {boolean} Register the default keyboard driver to this root?\n     * @constructor\n     */\n    constructor(wlObject, material, child, theme = new Theme(), unitsPerPixel = 0.01, registerPointerDriver = true, registerKeyboardDriver = true) {\n        super(child, style => { WL.canvas.style.cursor = style }, theme);\n        this.unitsPerPixel = unitsPerPixel;\n\n        // Create the child object where the mesh and collider will be put.\n        // Starts inactive since the mesh won't be ready yet\n        this.meshObject = WL.scene.addObject(wlObject);\n        this.meshObject.active = false;\n\n        // Setup drivers\n        if(registerPointerDriver)\n            this.registerDriver(WLRoot.pointerDriver);\n        if(registerKeyboardDriver)\n            this.registerDriver(WLRoot.keyboardDriver);\n\n        // Setup mesh for rendering in world\n        this.mesh = this.meshObject.addComponent('mesh');\n        // keep clone as a variable instead of accessing it later via\n        // this.mesh.material because mesh's material setter wraps the material,\n        // so it can't be reused\n        this.materialClone = material.clone();\n        this.mesh.material = this.materialClone;\n        this.oldTexSize = [0, 0];\n        this._setupMesh(1, 0);\n\n        // Setup mouse pointer input\n        this.collision = this.meshObject.addComponent('collision', {\n            collider: WL.Collider.Box,\n            extents: [1, 1, 0.01],\n            group: 0b00000010, // group 1\n        });\n        const target = this.meshObject.addComponent('cursor-target');\n        const cursorPos = new Float32Array(3);\n        const pos = new Float32Array(3);\n        const getCursorPos = cursor => {\n            cursorPos.set(cursor.rayHit.locations[0]);\n            this.meshObject.getTranslationWorld(pos);\n            vec3.sub(cursorPos, cursorPos, pos);\n            vec3.div(cursorPos, cursorPos, this.meshObject.scalingLocal);\n\n            return [\n                Math.min(Math.max((cursorPos[0] + 1) / 2, 0), 1),\n                Math.min(Math.max(1 - ((cursorPos[1] + 1) / 2), 0), 1),\n            ];\n        }\n\n        if(registerPointerDriver) {\n            target.addUnHoverFunction((_, cursor) => {\n                WLRoot.pointerDriver.leavePointer(\n                    this, WLRoot.getPointerID(cursor)\n                );\n            });\n            target.addCursorMoveFunction((_, cursor) => {\n                WLRoot.pointerDriver.movePointer(\n                    this, WLRoot.getPointerID(cursor), ...getCursorPos(cursor)\n                );\n            });\n            target.addCursorDownFunction((_, cursor) => {\n                WLRoot.pointerDriver.movePointer(\n                    this, WLRoot.getPointerID(cursor), ...getCursorPos(cursor), true\n                );\n            });\n            target.addCursorUpFunction((_, cursor) => {\n                WLRoot.pointerDriver.movePointer(\n                    this, WLRoot.getPointerID(cursor), ...getCursorPos(cursor), false\n                );\n            });\n        }\n\n        this.valid = true;\n    }\n\n\n    /**\n     * Do a full update of this root. Does a pre-layout update, resolves the\n     * layout, does a post-layout update and paints. Call this instead of the\n     * individual Root update methods.\n     */\n    update() {\n        if(!this.valid)\n            return;\n\n        // Update (pre-layout)\n        this.preLayoutUpdate();\n\n        // Resolve layout\n        const layoutDirty = this.resolveLayout();\n        const [canvasWidth, canvasHeight] = this.canvasDimensions;\n        if(layoutDirty) {\n            //console.log('Root\\'s layout was dirty, resizing');\n            // Resize and update UV if layout was dirty so that UI is not\n            // stretched\n            const [width, height] = this.dimensions;\n            this.meshObject.resetScaling();\n            this.meshObject.scale([\n                this.unitsPerPixel * width,\n                this.unitsPerPixel * height,\n                0.01,\n            ]);\n            this.collision.extents = [\n                this.meshObject.scalingLocal[0],\n                this.meshObject.scalingLocal[1],\n                0.01,\n            ];\n\n            // XXX FIXME for now, use the workaround (setupMesh)\n            /*const vertexData = this.mesh.mesh.vertexData;\n            const u = width / canvasWidth;\n            const v = 1 - (height / canvasHeight);\n            this._setUV(vertexData, 1, u, 1); // top-right\n            this._setUV(vertexData, 2, 0, v); // bottom-left\n            this._setUV(vertexData, 3, u, v); // bottom-right\n            this.mesh.mesh = this.mesh.mesh;\n            this.mesh.active = false;\n            this.mesh.active = true;*/\n            this._setupMesh(width / canvasWidth, 1 - (height / canvasHeight));\n        }\n\n        // Update (post-layout)\n        this.postLayoutUpdate();\n\n        // Paint\n        const wasDirty = this.paint();\n\n        // Enable child object if the canvas is enabled\n        this.meshObject.active = this.enabled;\n\n        if(!wasDirty)\n            return;\n\n        // Update texture if needed (if root was dirty)\n        if(this.oldTexSize[0] !== canvasWidth || this.oldTexSize[1] !== canvasHeight) {\n            this.oldTexSize[0] = canvasWidth;\n            this.oldTexSize[1] = canvasHeight;\n            const mat = this.materialClone;\n            this.texture = new WL.Texture(this.canvas);\n            if(mat.shader === 'Flat Opaque Textured' || mat.shader === 'Flat Transparent Textured')\n                mat.flatTexture = this.texture;\n            else if(mat.shader == 'Phong Opaque Textured')\n                mat.diffuseTexture = this.texture;\n            else\n                console.error('Shader', mat.shader, 'not supported by WLRoot');\n        }\n        else {\n            //console.log('Root was dirty, updating texture');\n            this.texture.update();\n        }\n    }\n\n    _setVertex(vertexData, i, posX, posY, posZ, normX, normY, normZ, u, v) {\n        vertexData.set([posX, posY, posZ, u, v, normX, normY, normZ], i * WL.Mesh.VERTEX_FLOAT_SIZE);\n    }\n\n    _setUV(vertexData, i, u, v) {\n        vertexData.set([u, v], i * WL.Mesh.VERTEX_FLOAT_SIZE + WL.Mesh.TEXCOORD.U);\n    }\n\n    _setupMesh(u, v) {\n        const indexData = new Uint8Array([\n            0, 3, 1, // top-right triangle\n            0, 2, 3, // bottom-left triangle\n        ]);\n        const vertexData = new Float32Array(4 * WL.Mesh.VERTEX_FLOAT_SIZE);\n        this._setVertex(vertexData, 0, -1,  1, 0, 0, 0, 1, 0, 1); // top-left\n        this._setVertex(vertexData, 1,  1,  1, 0, 0, 0, 1, u, 1); // top-right\n        this._setVertex(vertexData, 2, -1, -1, 0, 0, 0, 1, 0, v); // bottom-left\n        this._setVertex(vertexData, 3,  1, -1, 0, 0, 0, 1, u, v); // bottom-right\n        this.mesh.mesh = new WL.Mesh({\n            indexData,\n            indexType: WL.MeshIndexType.UnsignedByte,\n            vertexData,\n        });\n    }\n}\n", "import { VirtualKeyboard, defaultVirtualKeyboardTemplate, Theme, Margin } from 'canvas-ui';\nimport { WLRoot } from './WLRoot';\n\n/**\n * @module canvas-ui-wl\n */\n\n/**\n * A WLRoot with a virtual keyboard, similar to VirtualKeyboardRoot from\n * canvas-ui. Can also be automatically hidden when there is no keyboard focus\n * by callid updateVisibility before calling update. This doesn't need to be\n * directly used, the virtual-keyboard-ui-root component can be used instead.\n */\nexport class WLVirtualKeyboardRoot extends WLRoot {\n    /**\n     * Create a new WLVirtualKeyboardRoot.\n     * @param wlObject {Object} The object where the mesh will be added\n     * @param material {Material} The material to use for this root's mesh. The material will be cloned\n     * @param keyboardTemplate {VirtualKeyboardTemplate} The virtual keyboard's layout template. Uses the US QWERTY layout by default.\n     * @param keyboardDriver {KeyboardDriver | null} The KeyboardDriver to dispatch key events to. If null (default), WLRoot.keyboardDriver is used.\n     * @param theme {Theme} The root's theme. If none is supplied, the default theme is used\n     * @param unitsPerPixel {number} The amount of world units per canvas pixel. Determines the pixel density of the mesh\n     * @param registerPointerDriver {boolean} Register the default pointer driver to this root?\n     * @constructor\n     */\n    constructor(wlObject, material, keyboardTemplate = defaultVirtualKeyboardTemplate, keyboardDriver = null, theme = new Theme(), unitsPerPixel = 0.01, registerPointerDriver = true) {\n        if(keyboardDriver === null)\n            keyboardDriver = WLRoot.keyboardDriver;\n\n        super(\n            wlObject, material,\n            new Margin(new VirtualKeyboard(keyboardDriver, keyboardTemplate)),\n            theme, unitsPerPixel, registerPointerDriver, false,\n        );\n\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Automatically enables/disables this root if needed/unneeded. Call this\n     * before calling update.\n     */\n    updateVisibility() {\n        if(!this.valid)\n            return;\n\n        // Update visibility of virtual keyboard\n        this.enabled = this.keyboardDriver.getFocusedRoot() !== null;\n    }\n}\n", "import { WLVirtualKeyboardRoot } from '../core/WLVirtualKeyboardRoot';\n/*global WL*/\n\nWL.registerComponent('virtual-keyboard-ui-root', {\n    /** Material to apply the canvas texture to */\n    material: {type: WL.Type.Material},\n}, {\n    init() {\n        this.root = new WLVirtualKeyboardRoot(this.object, this.material);\n        this.forceDisabled = false;\n    },\n    update(_dt) {\n        if(this.root && !this.forceDisabled) {\n            this.root.updateVisibility();\n            this.root.update();\n        }\n    },\n    onActivate() {\n        if(this.root) {\n            this.forceDisabled = false;\n            this.root.enabled = true;\n        }\n    },\n    onDeactivate() {\n        if(this.root) {\n            this.forceDisabled = true;\n            this.root.enabled = false;\n        }\n    },\n});\n"],
  "mappings": "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",
  "names": []
}
